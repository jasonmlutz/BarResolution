i30 : peek U

o30 = PolynomialRing of RingElement{(%, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:476:22-476:48]*}                                                                                                                    }
                                    (*, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:541:22-541:48]*}
                                    (-, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:520:22-520:48]*}
                                    (/, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:611:22-611:37]*}
                                    (==, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:587:22-587:39]*}
                                    (?, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:148:21-148:36]*}
                                    (_, U, monoid[y , y , z , z , Degrees => {4:1}, Heft => {1}, MonomialOrder => {MonomialSize => 32}, DegreeRank => 1]) => {*Function[../../Macaulay2/share/Macaulay2/Core/orderedmonoidrings.m2:240:27-240:78]*}
                                                   1   2   1   2                                                  {GRevLex => {4:1}  }
                                                                                                                  {Position => Up    }
                                    (fraction, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:296:29-296:75]*}
                                    (lift, List, U, QQ) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:171:44-171:65]*}
                                    (lift, List, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:139:29-139:43]*}
                                    (lift, List, U, ZZ) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:190:50-190:75]*}
                                    (lift, Matrix, U, QQ) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:169:46-169:87]*}
                                    (lift, Matrix, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:140:31-140:45]*}
                                    (lift, Matrix, U, ZZ) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:188:49-188:91]*}
                                    (lift, Module, U, QQ) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:167:46-167:80]*}
                                    (lift, Module, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:142:31-142:45]*}
                                    (lift, Module, U, ZZ) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:186:49-186:84]*}
                                    (lift, U, QQ) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:165:39-165:75]*}
                                    (lift, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:135:24-135:36]*}
                                    (lift, U, ZZ) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:184:39-184:74]*}
                                    (promote, List, QQ, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:170:50-170:62]*}
                                    (promote, List, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:137:35-137:38]*}
                                    (promote, List, ZZ, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:189:50-189:78]*}
                                    (promote, Matrix, QQ, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:168:52-168:78]*}
                                    (promote, Matrix, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:138:37-138:40]*}
                                    (promote, Matrix, ZZ, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:187:52-187:79]*}
                                    (promote, Module, QQ, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:166:52-166:78]*}
                                    (promote, Module, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:141:37-141:40]*}
                                    (promote, Module, ZZ, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:185:52-185:79]*}
                                    (promote, QQ, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:163:37-163:71]*}
                                    (promote, U, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:136:28-136:31]*}
                                    (promote, ZZ, U) => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:182:37-182:71]*}
                                    0 => 0
                                    1 => 1
                                    basering => QQ
                                    baseRings => {ZZ, QQ}
                                    char => 0
                                    degreesMonoid => monoid[T, Degrees => {1}, MonomialOrder => {MonomialSize => 32}, DegreeRank => 1, Inverses => true, Global => false]
                                                                                                {Weights => {-1}   }
                                                                                                {GroupLex => 1     }
                                                                                                {Position => Up    }
                                    degreesRing => ZZ[T]
                                    Engine => true
                                    expression => {*Function[../../Macaulay2/share/Macaulay2/Core/orderedmonoidrings.m2:246:35-253:43]*}
                                    factor => {*Function[../../Macaulay2/share/Macaulay2/Core/orderedmonoidrings.m2:267:29-284:76]*}
                                    FlatMonoid => monoid[y , y , z , z , Degrees => {4:1}, Heft => {1}, MonomialOrder => {MonomialSize => 32}, DegreeRank => 1]
                                                          1   2   1   2                                                  {GRevLex => {4:1}  }
                                                                                                                         {Position => Up    }
                                    frac => frac(U)
                                    generatorExpressions => {y , y , z , z }
                                                              1   2   1   2
                                    generators => {y , y , z , z }
                                                    1   2   1   2
                                    generatorSymbols => {y , y , z , z }
                                                          1   2   1   2
                                    indexStrings => HashTable{y_1 => y }
                                                                      1
                                                              y_2 => y
                                                                      2
                                                              z_1 => z
                                                                      1
                                                              z_2 => z
                                                                      2
                                    indexSymbols => HashTable{y  => y }
                                                               1     1
                                                              y  => y
                                                               2     2
                                                              z  => z
                                                               1     1
                                                              z  => z
                                                               2     2
                                    isCommutative => true
                                    isPrime => {*Function[../../Macaulay2/share/Macaulay2/Core/orderedmonoidrings.m2:285:27-289:80]*}
                                    liftDegree => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:59:20-61:38]*}
                                    monoid => monoid[y , y , z , z , Degrees => {4:1}, Heft => {1}, MonomialOrder => {MonomialSize => 32}, DegreeRank => 1]
                                                      1   2   1   2                                                  {GRevLex => {4:1}  }
                                                                                                                     {Position => Up    }
                                    numallvars => 4
                                    promoteDegree => {*Function[../../Macaulay2/share/Macaulay2/Core/enginering.m2:59:20-61:38]*}
                                    raw creation log => {*a bagged function application expression*}
                                    RawRing => QQ[y_1,y_2,z_1,z_2,
                                                 DegreeLength => 1,
                                                 Degrees => {1, 1, 1, 1},
                                                 Heft => {1},
                                                 MonomialOrder => {
                                                   GRevLex => {1,1,1,1},
                                                   Position => Up
                                                   }
                                                 ]
